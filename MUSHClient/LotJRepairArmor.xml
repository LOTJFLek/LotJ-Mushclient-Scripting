<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<!--  Saved on Sunday, April 04, 2010, 8:43 PM   --> 
<!--  MuClient version 4.40   --> 
<!--  Plugin "LotJRepairing" generated by Plugin Wizard   --> 
<muclient>
<plugin name="LotJRepair" author="@Ilyena,@Johnson,mod:@Klor" id="e7552294d01c360ac74c5d90" language="Lua" purpose="To make repairing armor easier!" save_state="y" date_written="2021-02-10 20:42:01" requires="4.40" version="1.05">
<description trim="y">
<![CDATA[ 'Repairahelp' - To see the commands available in the game.

The code will automatically go through the list, repairing everything.

  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
  <include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>
  <trigger enabled="n" group="LotJRepair" match="^You don\'t have that item\!$" name="MissingArmor" regexp="y" script="repairaNext" sequence="100" /> 
  <trigger enabled="n" group="LotJRepair" match="^Thats not a piece of armor\!$" name="BadArmor" regexp="y" script="repairaNext" sequence="100" />
  <trigger enabled="n" group="LotJRepair" match="^It doesn\'t look very damaged at all\!$" name="FixedArmor" regexp="y" script="finishedArmor" sequence="100" />
  <trigger enabled="n" group="LotJRepair" keep_evaluating="y" match="^You finish your work and hold up the fully repaired armor\.$" name="FinishedArmor" regexp="y" script="finishedArmor" sequence="100" /> 
  <trigger enabled="n" group="LotJRepair" keep_evaluating="y" match="^You finish your work and hold up the fully repaired container\.$" name="FinishedContainer" regexp="y" script="finishedArmor" sequence="100" /> 
  <trigger enabled="n" group="LotJRepair" keep_evaluating="y" match="^You finish your work and hold up the fully repaired shield\.$" name="FinishedShield" regexp="y" script="finishedArmor" sequence="100" /> 
  <trigger enabled="n" group="LotJRepair" match="^You are no longer afk\.$" name="afkoff" regexp="y" script="afkOff" sequence="100" />
  <trigger enabled="n" group="LotJRepair" match="^You are now afk\.$" name="afkon" regexp="y" script="afkOn" sequence="100" />
  </triggers>
<!--   Aliases    --> 
<aliases>
  <alias name="AddRepairaArmor" script="addRepairaArmor" match="^repairaadd (.*)$" enabled="y" group="LotJRepair" regexp="y" sequence="100" /> 
  <alias name="RemoveRepairaArmor" script="removeRepairaArmor" match="^repairarem (.*)$" enabled="y" group="LotJRepair" regexp="y" sequence="100" /> 
  <alias name="DisplayRepairaCommands" script="displayRepairaCommands" match="repairahelp" enabled="y" group="LotJRepair" send_to="1" sequence="100" /> 
  <alias name="ClearList" script="clearList" match="repairaclear" enabled="y" group="LotJRepair" send_to="1" sequence="100" /> 
  <alias name="AutoRepairaStatus" script="setRepairaStatus" match="^repairaauto( +(.*))?$" enabled="y" group="LotJRepair" regexp="y" ignore_case="y" sequence="100" /> 
  <alias name="ShowRepairaList" script="showRepairaList" match="repairalist" enabled="y" group="LotJRepair" send_to="1" sequence="100" /> 
  <alias name="StartRepairaing" script="startRepairaing" match="repairastart" enabled="y" group="LotJRepair" send_to="1" ignore_case="y" sequence="100" /> 
  <alias name="SkipArmor" script="repairaNext" match="repairanext" enabled="y" group="LotJRepair" send_to="1" sequence="100" /> 
  <alias name="ToggleAutoRepairaStatus" script="setRepairaStatus" match="repairaauto" enabled="y" group="LotJRepair" send_to="1" ignore_case="y" sequence="100" /> 
  <alias name="Repaira" script="repairaArg" match="^repaira(?:\s+(.*))?$" regexp="y" enabled="y" group="LotJRepair" ignore_case="y" sequence="100" />

  </aliases>
<!--   Script    --> 
<script>
<![CDATA[ 

require "serialize"

repairaList = {}
afk = false
repairaArmor =     GetVariable("repairaArmor") or ""
repairaStatus =   ((GetVariable("repairaStatus") or "false") == "true") -- default to false "deactivated"
currentPos =    tonumber(GetVariable("currentPos") or 0)
repairaNum =      tonumber(GetVariable("repairaNum") or 0)
loadstring (GetVariable("repairaList") or "")()

function OnPluginInstall()
  EnableTriggerGroup("LotJRepair", repairaStatus) -- this is to reactivate upon plugin reload
end

function OnPluginSaveState()
  SetVariable("repairaArmor", repairaArmor)
  SetVariable("repairaStatus", tostring(repairaStatus))
  SetVariable("currentPos", tostring(currentPos))
  SetVariable("repairaNum", tostring(repairaNum))
  SetVariable("repairaList", serialize.save("repairaList"))
end

function showRepairaList(name, line, args)
  ColourNote("silver","","Repair list contains ","cyan","",#repairaList,"silver",""," pieces: ")
  for i, v in ipairs(repairaList) do
    ColourNote("dimgray","",string.format("%-2d",i)..": ","dimgray","",v,"cyan","",((currentPos==i and " <[--") or ""))
  end
  if repairaArmor ~= repairaList[currentPos] then -- we're repairing something not in the list
    ColourNote("silver","","Currently repairing: ","cyan","",repairaArmor)
  end
 end

function setRepairaStatus(name, line, args)
  if repairaStatus then
    toggleOff()
  else
    toggleOn()
  end
end

function toggleOn(name, line, args)
  repairaStatus = true
  EnableTriggerGroup("LotJRepair", true)
  ColourNote("yellow","","LotJRepair activated.")
end
function toggleOff(name, line, args)
  repairaStatus = false
  EnableTriggerGroup("LotJRepair", false)
  ColourNote("yellow","","LotJRepair deactivated.")
end

function displayRepairaCommands(name, line, wildcards)
  ColourNote("silver","","LotJRepair help info:")
  ColourNote("white","","Repaira                         - Repair current armor")
  ColourNote("white","","Repairastart                    - Begin repairing from front of list")
  ColourNote("white","","Repairaadd <item>,<item>,<item> - Add objects to repair list")
  ColourNote("white","","Repairarem <item>               - Remove objects from repair list")
  ColourNote("white","","Repairalist                     - Display repair list")
  ColourNote("white","","Repairanext                     - Skip armor in repair list")
  ColourNote("white","","Repairaauto                     - Toggles automatic repairing")
  ColourNote("white","","Repairaclear                    - Erase stored repair data")
end -- function

function startRepairaing(name, line, wildcards)
  if (#repairaList > 0) then -- we have stuff to repair!
    currentPos = 0
    repairaNext()
    toggleOn()
  else                     -- nothing to repair
    ColourNote("red","","Nothing to repair!")
    toggleOff()
  end
end


function repaira(name, line, args)
  if repairaArmor ~= "" and repairaArmor ~= nil then
    Send("repaira ".. repairaArmor)
  end
end

function finishedArmor()
  if repairaArmor ~= "" then
    internalRemove(repairaArmor)
  else
    internalRemove(currentPos)
  end
  currentPos = currentPos - 1 -- decrement list pointer to properly get/take from container  
  repairaNext()
end

function internalRemove(armor)
   t = #repairaList
   for i, v in ipairs(repairaList) do
      if (v == armor or (i == tonumber(armor))) then
         ColourNote("red","","Removed '" .. v .. "' from repair list.")
         table.remove(repairaList, i)
         if (currentPos > i) then  -- if our armor is higher in the list than what we remove
           currentPos = currentPos - 1  -- decrement the pointer to follow the current armor
         end
         break
      else
         if (t == i) then
            ColourNote("red","","Armor '" .. armor .. "' not found in repair list.")
         end -- if
      end -- if
   end -- for
end -- function

function repairaNext(name, line, args)
  if (currentPos > 0) then           -- if you're working on an previous armor
  end
  currentPos = currentPos + 1
  if (currentPos > #repairaList) then  -- reached end of list
      toggleOff()
  else                                    -- middle of list
    repairaArmor = repairaList[currentPos]
    repaira()  -- finally, repaira armor
  end
end



function afkOn(name, line, args)
  afk = true
end

function afkOff(name, line, args)
  afk = false
end

function addRepairaArmor(name, line, args)
  local addLines = args[1]
  if args[1] and args[1]:find(",") then
    addLines = utils.split(args[1], ",")
  elseif args[1] and args[1]:find(" ") then
    addLines = utils.split(args[1], " ")
  else
    addLines = args[1]
  end
  if type(addLines)=="table" then
    for i, v in ipairs(addLines) do
      if tonumber(v) then -- gave a number, insert previous armor at index instead of appending
        table.insert(repairaList, tonumber(v), table.remove(repairaList, #repairaList))
        ColourNote("silver","","Armor '","cyan","",repairaList[tonumber(v)],"silver","","' inserted to repair list index ","cyan","",tonumber(v),"silver","",".")
        if currentPos >= tonumber(v) then -- pointer needs to be shifted up
          currentPos = currentPos + 1
        end
      else -- new armor, append it
        repairaList[#repairaList + 1] = v
        ColourNote("silver","","Added '","cyan","",repairaList[#repairaList],"silver","","' to repair list.")
      end
    end
  else -- got a string, single armor add
    repairaList[#repairaList + 1] = addLines
    ColourNote("silver","","Added '","cyan","",repairaList[#repairaList],"silver","","' to repair list.")
  end
end -- function

function repairaArg(name, line, args)
  args = utils.split(args[1], " ")
  if args[1] ~= nil and args[1] ~= "" and #args == 1 then -- entered one argument, start repairing that armor
    repairaArmor = Trim(args[1])
  elseif repairaArmor ~= "" then
    -- do nothing here so we will fall back to repaira()
  elseif repairaList[currentPos] then -- no argument, repair list has valid armor, repair it
    repairaArmor = repairaList[currentPos]
  else -- no argument, no valid armor in list
    Send("repairarmor "..table.concat(args, " ")) -- pass through whatever we typed here
    return
  end
  repaira()
end

function removeRepairaArmor(name, line, wildcards)
   t = #repairaList
   for i, v in ipairs(repairaList) do
      if (v == wildcards[1] or (i == tonumber(wildcards[1]))) then
         ColourNote("red","","Removed '" .. v .. "' from repair list.")
         table.remove(repairaList, i)
         if (currentPos > i) then  -- if our armor is higher in the list than what we remove
           currentPos = currentPos - 1  -- decrement the pointer to follow the current armor
         end
         break
      else
         if (t == i) then
            ColourNote("red","","Armor '" .. wildcards[1] .. "' not found in repair list.")
         end -- if
      end -- if
   end -- for
end -- function

function clearList(name, line, wildcards)
  if (currentPos > 0) then           -- if you're working on an previous armor
  end
  repairaList = {}
  ColourNote("yellow","","Repair list cleared.")
  currentPos = 0
  toggleOff()
  OnPluginSaveState() -- update stored values
end -- function

  ]]> 
  </script>
 <!--   Plugin help    --> 
 <aliases>
  <alias script="OnHelp" match="LotJRepairing:help" enabled="y" /> 
  </aliases>
 <script>
 <![CDATA[ function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

  ]]> 
  </script>
  </muclient>
